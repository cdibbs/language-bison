"name": "Jison"
scopeName: "source.jison"
fileTypes: ["jison"]

patterns: [
  {
    # Like Bison
    # (https://www.gnu.org/software/bison/manual/html_node/Grammar-Outline.html),
    # Jison files are divided into four sections:
    #   %{
    #     Prologue
    #   %}
    #   Declarations
    #   %%
    #   Grammar rules
    #   %%
    #   Epilogue
    # Because there can be more than one prologue, another way to look at Jison
    # files is that they’re divided into three sections separated by %%, just
    # like Jison Lex files.
    begin: "%%"
    beginCaptures: 0: name: "meta.separator.section.jison"
    patterns: [
      {
        begin: "%%"
        beginCaptures: 0: name: "meta.separator.section.jison"
        patterns: [
          {
            name:  "meta.section.epilogue.jison"
            begin: "(?!%%)"
            patterns: [include: "#epilogue_section"]
          }
        ]
      },{
        name:  "meta.section.rules.jison"
        begin: "(?!%%)"
        end:   "(?=%%)"
        patterns: [include: "#rules_section"]
      }
    ]
  },{
    name:  "meta.section.declarations.jison"
    begin: "(?!%%)"
    end:   "(?=%%)"
    patterns: [include: "#declarations_section"]
  }
]


repository:
  declarations_section:
    patterns: [
      {include: "#comments"}

      # Jison declarations sections can have lexers embedded between %lex and
      # /lex.
      {
        begin: "^\\s*(%lex)\\s*$"
        end:   "^\\s*(/lex)\\b"
        # There may be a better choice of scope than “entity.name.tag”, but
        # using a tag scope makes the start and end matches stand out. Also, the
        # end match “/lex” is somewhat like an end tag.
        beginCaptures: 1: name: "entity.name.tag.lexer.begin.jison"
        endCaptures:   1: name: "entity.name.tag.lexer.end.jison"
        # Simply setting the patterns object to {include: "source.jisonlex"}
        # here doesn’t work for several reasons:
        # - The Jison Lex grammar’s rules section treats /lex as a valid regex
        #   pattern; /lex is the same as (?=lex).
        # - The user-code section treats /lex as a division operator followed by
        #   the identifier “lex”.
        # - The user-code section also does not end.
        # This is the Jison Lex grammar with end patterns that circumvent these
        # issues.
        patterns: [
          {
            begin: "%%"
            end:   "(?=/lex)"
            beginCaptures: 0: name: "meta.separator.section.jisonlex"
            patterns: [
              {
                begin: "^%%"
                end:   "(?=/lex)"
                beginCaptures: 0: name: "meta.separator.section.jisonlex"
                patterns: [
                  {
                    name:  "meta.section.user-code.jisonlex"
                    begin: "(?!%%)"
                    end:   "(?=/lex)"
                    patterns: [include: "source.jisonlex#user_code_section"]
                  }
                ]
              },{
                name:  "meta.section.rules.jisonlex"
                begin: "(?!%%)"
                end:   "(?=^(?:%%|/lex))"
                patterns: [include: "source.jisonlex#rules_section"]
              }
            ]
          },{
            name:  "meta.section.definitions.jisonlex"
            begin: "(?!%%)"
            end:   "(?=%%|/lex)"
            patterns: [include: "source.jisonlex#definitions_section"]
          }
        ]
      }

      {
        name:  "meta.section.prologue.jison"
        begin: "(?=%\\{)"
        end:   "(?<=%\\})"
        patterns: [include: "#user_code_blocks"]
      }

      {include: "#options_declarations"}

      {
        include: "#declarations"
      }
    ]

  rules_section:
    patterns: [
      {include: "#comments"}
      {include: "#actions"}
      {
        include: "#rules"
      }
    ]

  epilogue_section:
    patterns: [
      {
        include: "source.js"
        comment: "Epilogue contains Javascript code only"
      }
    ]


  declarations:
    patterns: [
      {
        include: "#directives"
      }
      {
        include: "#types"
      }
      {
        include: "#symbols"
      }
      {
        include: "#numbers"
      }
      {
        include: "#block"
      }
      {
        include: "#strings"
      }
      {
        match: "\\;"
        comment: "Semicolon can be only at the end of a union"
        name: "punctuation.union-declaration.end.jison"
      }
    ]
  rules:
    patterns: [
      {
        begin: "([a-zA-Z_.\-][a-zA-Z_.\-0-9]*)[ \\t\\n\\r]*(:)"
        end: ";"
        beginCaptures:
          1:
            name: "variable.grammar-rule.token-def.jison"
            comment: "Match the result of the grammar rule"
          2:
            name: "punctuation.grammar-rule.result-separator.jison"     # :
        endCaptures:
          0:
            name: "punctuation.grammar-rule.end.jison"
        comment: "Match grammar rules, second section only"
        name: "meta.grammar-rule.jison"
        patterns: [
          {include: "#comments"}
          {
            include: "#components"
          }
        ]
      }
    ]
  components:
    patterns: [
      {
        begin: "(?=([a-zA-Z_.\-][a-zA-Z_.\-0-9]*)?)"  # (?) Comp can be empty
        end: "\\||(?=;)"
        endCaptures:
          0:
            name: "punctuation.grammar-rule.component-separator.jison"  # |
        comment: "Match each component in a grammar rule"
        name: "meta.section.component.jison"
        patterns: [
          {include: "#comments"}
          {
            begin: "'"
            beginCaptures:
              0:
                name: "punctuation.definition.string.begin.jison"
            end: "'"
            endCaptures:
              0:
                name: "punctuation.definition.string.end.jison"
            comment: "Match single character tokens inside components"
            name: "string.quoted.single.character-token.jison"
            patterns: [
              #TODO {
              #  include: "#string_escaped_char"
              #}
              # {
              #  include: "#line_continuation_character"
              #}
            ]
          }
          {
            include: "#directives"
          }
          {
            include: "#symbols"
          }
          {
            include: "#rule_actions"
          }
        ]
      }
    ]
  directives:
    patterns: [
      {
        match: "%[a-z\-]+"
        comment: "Match %-directives"
        name: "keyword.control.directive.jison"
      }
    ]
  symbols:
    patterns: [
      {
        match: "[a-zA-Z_.\-][a-zA-Z_.\-0-9]*"
        comment: "Match valid symbols"
        name: "variable.grammar-rule.token-type.jison"
      }
    ]
  types:
    patterns: [
      {
        begin: "<"
        end: ">"
        beginCaptures:
          0:
            name: "punctuation.type-declaration.begin.jison"
        endCaptures:
          0:
            name: "punctuation.type-declaration.end.jison"
        comment: "Match type declarations"
        patterns: [
          {
            match: "[$a-zA-Z\_][$a-zA-Z0-9\_]*"
            comment: "A valid JS identifier"
          }
        ]
      }
    ]

  actions:
    patterns: [
      {
        name:  "meta.action.jison"
        begin: "\\{\\{"
        end:   "\\}\\}"
        beginCaptures: 0: name: "punctuation.definition.action.begin.jison"
        endCaptures:   0: name: "punctuation.definition.action.end.jison"
        patterns: [include: "source.js"]
      },{
        name:  "meta.action.jison"
        begin: "(?=%\\{)"
        end:   "(?<=%\\})"
        patterns: [include: "#user_code_blocks"]
      }
    ]
  rule_actions:
    patterns: [
      {include: "#actions"}
      {
        name: "meta.action.jison"
        begin: "\\{"
        end:   "\\}"
        beginCaptures: 0: name: "punctuation.definition.action.begin.jison"
        endCaptures:   0: name: "punctuation.definition.action.end.jison"
        patterns: [include: "source.js"]
      }
      {
        name:  "meta.action.jison"
        begin: "->"
        end:   "((//).*)?(?=$)"
        beginCaptures:
          0: name: "punctuation.definition.action.arrow.jison"
        endCaptures:
          1: name: "comment.line.double-slash.js"
          2: name: "punctuation.definition.comment.js"
        # TODO: The end pattern is based on the comment.line.double-slash.js
        # pattern in
        # https://github.com/atom/language-javascript/blob/master/grammars/javascript.cson.
        # The end pattern of comment.line.double-slash.js is itself $, so $
        # can’t be the end pattern here because it will never be matched. Is
        # there an end pattern that can be used here that doesn’t duplicate a
        # JavaScript grammar pattern?
        patterns: [include: "source.js"]
      }
    ]

  comments:
    patterns: [
      {
        name:  "comment.line.double-slash.jison"
        begin: "//"
        end:   "(?=\\n)"
        beginCaptures: 0: name: "punctuation.definition.comment.jison"
      },{
        name:  "comment.block.jison"
        begin: "/\\*"
        end:   "\\*/"
        beginCaptures: 0: name: "punctuation.definition.comment.begin.jison"
        endCaptures:   0: name: "punctuation.definition.comment.end.jison"
      }
    ]

  numbers:
    patterns: [
      {
        match: "\\b((0(x|X)[0-9a-fA-F]*)|(([0-9]+\\.?[0-9]*)|(\\.[0-9]+))((e|E)(\\+|-)?[0-9]+)?)(L|l|UL|ul|u|U|F|f|ll|LL|ull|ULL)?\\b"
        name: "constant.numeric.c"
      }
    ]

  options_declarations:
    patterns: [
      {
        name:  "meta.options.jison"
        begin: "%options\\b"
        end:   "$"
        beginCaptures: 0: name: "keyword.other.options.jison"
        patterns: [
          {
            name:  "entity.name.constant.jison"
            match: "\\b[\\p{Alpha}_](?:[\\w-]*\\w)?\\b"
          },{
            begin: "(=)\\s*"
            end:   "(?<=['\"])|(?=\\s)"
            beginCaptures: 1: name: "keyword.operator.option.assignment.jison"
            patterns: [
              {include: "quoted_strings"}
              {
                name:  "string.unquoted.jison"
                match: "\\S+"
              }
            ]
          }
          {include: "quoted_strings"}
        ]
      }
    ]

  quoted_strings:
    patterns: [
      {
        name:  "string.quoted.double.jison"
        begin: '"'
        end:   '"'
        # https://github.com/atom/language-javascript/blob/master/grammars/javascript.cson
        patterns: [include: "source.js#string_escapes"]
      },{
        name:  "string.quoted.single.jison"
        begin: "'"
        end:   "'"
        patterns: [include: "source.js#string_escapes"]
      }
    ]

  block:
    patterns: [
      {
        begin: "\\{"
        beginCaptures:
          0:
            name: "punctuation.section.block.begin.c"
        end: "\\}|(?=\\s*#\\s*endif\\b)"
        endCaptures:
          0:
            name: "punctuation.section.block.end.c"
        name: "meta.block.c"
        patterns: [
          {
            include: "source.js"
          }
        ]
      }
    ]

  user_code_blocks:
    patterns: [
      {
        name:  "meta.user-code-block.jison"
        begin: "%\\{"
        end:   "%\\}"
        beginCaptures: 0: name: "punctuation.definition.user-code-block.begin.jison"
        endCaptures:   0: name: "punctuation.definition.user-code-block.end.jison"
        patterns: [include: "source.js"]
      }
    ]


# These are from https://github.com/GerHobbelt/jison/blob/master/lib/jison.js.
injections:
  "L:meta.action.jison -(comment | string), source.js.embedded.source":
    patterns: [
      {
        name:  "variable.language.semantic-value.jison"
        match: "\\${2}"
      },{
        name:  "variable.language.result-location.jison"
        match: "@\\$"
      },{
        name:  "variable.language.stack-index-0.jison"
        match: "##\\$|\\byysp\\b"
      },{
        name:  "support.variable.token-reference.jison"
        match: "#\\S+#"
      },{
        name:  "variable.language.result-id.jison"
        match: "#\\$"
      },{
        name:  "support.variable.token-value.jison"
        match: "\\$(?:-?\\d+|[\\p{Alpha}_](?:[\\w-]*\\w)?)"
      },{
        name:  "support.variable.token-location.jison"
        match: "@(?:-?\\d+|[\\p{Alpha}_](?:[\\w-]*\\w)?)"
      },{
        name:  "support.variable.stack-index.jison"
        match: "##(?:-?\\d+|[\\p{Alpha}_](?:[\\w-]*\\w)?)"
      },{
        name:  "support.variable.token-id.jison"
        match: "#(?:-?\\d+|[\\p{Alpha}_](?:[\\w-]*\\w)?)"
      },{
        name:  "keyword.other.jison"
        match: "\\byy(?:clearin|erro[kr])\\b"
      }
    ]
