"name": "Jison Lex"
scopeName: "source.jisonlex"
fileTypes: ["jisonlex"]

patterns: [
  {
    # Like Flex (https://westes.github.io/flex/manual/Format.html), Jison Lex
    # files are divided into three sections separated by %%:
    #   definitions
    #   %%
    #   rules
    #   %%
    #   user code
    # Flex has the additional requirement that the %% must be the only thing in
    # a line, but thatâ€™s not the case for the separator between definitions and
    # rules in Jison Lex.
    begin: "%%"
    beginCaptures: 0: name: "meta.separator.section.jisonlex"
    patterns: [
      {
        # The separator between rules and user code in Jison Lex must be at the
        # beginning of a line.
        begin: "^%%"
        beginCaptures: 0: name: "meta.separator.section.jisonlex"
        patterns: [
          {
            name:  "meta.section.user-code.jisonlex"
            begin: "(?!%%)"
            patterns: [include: "#user_code_section"]
          }
        ]
      },{
        name:  "meta.section.rules.jisonlex"
        begin: "(?!%%)"
        end:   "(?=^%%)"
        patterns: [include: "#rules_section"]
      }
    ]
  },{
    name:  "meta.section.definitions.jisonlex"
    begin: "(?!%%)"
    end:   "(?=%%)"
    patterns: [include: "#definitions_section"]
  }
]

repository:
  definitions_section:
    patterns: [
      {include: "source.jison#comments"}

      {
        begin: "^(?i)([a-z_][a-z0-9_-]*)(?=\\s|$)"
        beginCaptures:
          1:
            name: "entity.name.function.jisonlex"
        end: "$"
        name: "meta.definition.jisonlex"
        patterns: [
          {include: "source.jison#comments"}
          {
            include: "#regexp"
          }
        ]
      }
      {
        begin: "^(%[sx])(?=\\s|$)"
        beginCaptures:
          1:
            name: "punctuation.definition.start-condition.jisonlex"
        end: "$"
        name: "meta.start-condition.jisonlex"
        patterns: [
          {include: "source.jison#comments"}
          {
            match: "(?i)[a-z_][a-z0-9_-]*"
          }
          {
            match: "\\S"
            name: "invalid.illegal.jisonlex"
          }
        ]
      }
      {
        begin: "^(%option)\\s(?=\\S)"
        beginCaptures:
          1:
            name: "keyword.other.option.jisonlex"
        end: "$"
        name: "meta.options.jisonlex"
        patterns: [
          {
            match: "\\b(?:(?:no)?(?:[78]bit|align|backup|batch|c\\+\\+|debug|default|ecs|fast|full|interactive|lex-compat|meta-ecs|perf-report|read|stdout|verbose|warn|array|pointer|input|unput|yy_(?:(?:push|pop|top)_state|scan_(?:buffer|bytes|string))|main|stack|stdinit|yylineno|yywrap)|(?:case(?:ful|less)|case-(?:in)?sensitive|(?:always|never)-interactive))\\b"
            name: "support.other.option.jisonlex"
          }
        ]
      }
      {
        begin: "^%(?:array|pointer)"
        end: "$"
        name: "keyword.other.option.jisonlex"
        patterns: [
          {
            match: "\\S"
            name: "invalid.illegal.jisonlex"
          }
        ]
      }
      {include: "source.jison#user_code_blocks"}
    ]

  rules_section:
    patterns: [
      {include: "source.jison#comments"}
      {
        begin: "^(?!$)"
        end: "$"
        name: "meta.rule.jisonlex"
        patterns: [
          {
            begin: "(?i)^(<(?:(?:[a-z_][a-z0-9_-]*,)*[a-z_][a-z0-9_-]|\\*)>)?(?:(<<EOF>>)(\\s*))?(?=\\S)"
            beginCaptures:
              1:
                name: "keyword.other.start-condition.jisonlex"
              2:
                name: "keyword.operator.eof.jisonlex"
              3:
                name: "invalid.illegal.regexp.jisonlex"
            comment: "rule pattern"
            end: "(?=\\s)|$"
            patterns: [
              {
                include: "#regexp"
              }
            ]
          },{
            name:  "meta.rule.action.jisonlex"
            begin: "(?=%\\{)"
            end:   "(?<=%\\})"
            patterns: [include: "source.jison#user_code_blocks"]
          },{
            begin: "(?=\\S)"
            comment: "TODO: eol should override embedded scopes"
            end: "$"
            name: "meta.rule.action.jisonlex"
            patterns: [
              {
                include: "#jssource"
              }
            ]
          }
        ]
      }
    ]

  user_code_section:
    patterns: [
      {
        include: "#jssource"
      }
    ]


  jssource:
    patterns: [
      {
        match: "\\b(?:ECHO|BEGIN|REJECT|YY_FLUSH_BUFFER|YY_BREAK|yy(?:more|less|unput|input|terminate|text|leng|restart|_(?:push|pop|top)_state|_(?:create|switch_to|flush|delete)_buffer|_scan_(?:string|bytes|buffer)|_set_(?:bol|interactive))(?=\\(|$))\\b"
        name: "support.function.js.jisonlex"
      }
      {
        include: "source.js"
      }
    ]

  re_escape:
    match: "\\\\(?i:[0-9]{1,3}|x[0-9a-f]{1,2}|.)"
    name: "constant.character.escape.jisonlex"
  rec_csource:
    begin: "\\{"
    end: "\\}"
    patterns: [
      {
        include: "source.js"
      }
      {
        include: "#jssource"
      }
    ]
  regexp:
    begin: "\\G(?=\\S)(\\^)?"
    captures:
      1:
        name: "keyword.control.anchor.regexp.jisonlex"
    end: "(\\$)?(?:(?=\\s)|$)"
    name: "string.regexp.jisonlex"
    patterns: [
      {
        include: "#subregexp"
      }
    ]
  subregexp:
    patterns: [
      {
        include: "#re_escape"
      }
      {
        begin: "(\\[)(\\^)?-?"
        beginCaptures:
          1:
            name: "punctuation.definition.character-class.set.jisonlex"
          2:
            name: "keyword.operator.negation.regexp.jisonlex"
        end: "-?(\\])"
        endCaptures:
          1:
            name: "punctuation.terminator.character-class.set.jisonlex"
        name: "constant.other.character-class.set.jisonlex"
        patterns: [
          {
            include: "#re_escape"
          }
          {
            captures:
              1:
                name: "invalid.illegal.regexp.jisonlex"
            match: "\\[:(?:(?:alnum|alpha|blank|cntrl|x?digit|graph|lower|print|punct|space|upper)|(.*?)):\\]"
            name: "constant.other.character-class.set.jisonlex"
          }
        ]
      }
      {
        match: "(?i){[a-z_][a-z0-9_-]*}"
        name: "variable.other.jisonlex"
      }
      {
        begin: "\\{"
        end: "\\}"
        name: "keyword.operator.quantifier.regexp.jisonlex"
        patterns: [
          {
            match: "(?<=\\{)[0-9]*(?:,[0-9]*)?(?=\\})"
          }
          {
            comment: "{3} counts should only have digit[,digit]"
            match: "[^}]"
            name: "invalid.illegal.regexp.jisonlex"
          }
        ]
      }
      {
        begin: "\""
        end: "\""
        name: "string.quoted.double.regexp.jisonlex"
        patterns: [
          {
            include: "#re_escape"
          }
        ]
      }
      {
        begin: "([*+?])(?=[*+?])"
        beginCaptures:
          1:
            name: "keyword.operator.quantifier.regexp.jisonlex"
        comment: "make ** or +? or other combinations illegal"
        end: "(?=[^*+?])"
        patterns: [
          {
            match: "."
            name: "invalid.illegal.regexp.jisonlex"
          }
        ]
      }
      {
        match: "[*+?]"
        name: "keyword.operator.quantifier.regexp.jisonlex"
      }
      {
        comment: "<<EOF>> is handled in the rule pattern"
        match: "<<EOF>>"
        name: "invalid.illegal.regexp.jisonlex"
      }
      {
        begin: "(\\()"
        beginCaptures:
          1:
            name: "punctuation.definition.group.regexp.jisonlex"
        end: "(\\))|(?=\\s)|$(?#end on whitespace because regex does)"
        endCaptures:
          1:
            name: "punctuation.terminator.group.regexp.jisonlex"
        name: "meta.group.regexp.jisonlex"
        patterns: [
          {
            match: "/"
            name: "invalid.illegal.regexp.jisonlex"
          }
          {
            include: "#subregexp"
          }
        ]
      }
      {
        begin: "(/)"
        beginCaptures:
          1:
            name: "keyword.operator.trailing-match.regexp.jisonlex"
        comment: "detection of multiple trailing contexts"
        end: "(?=\\s)|$"
        patterns: [
          {
            match: "/|\\$(?!\\S)"
            name: "invalid.illegal.regexp.jisonlex"
          }
          {
            include: "#subregexp"
          }
        ]
      }
    ]
